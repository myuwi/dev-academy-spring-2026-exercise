# Solita Dev Academy Spring 2026 Exercise

This is my (Miika Kurvinen) submission for the pre-assignment for Solita Dev Academy Finland March 2026.
The final application may be accessed at https://dev-academy.myuwi.dev/.

While the original assignment only required me to create a UI and a backend service, I have also gone ahead and implemented (some) unit, integration and e2e tests, containerization via Docker, continuous integration and delivery via GitHub Actions, container orchestration via Docker Swarm, reverse proxying and load balancing via Traefik, as well as other niceties, which are detailed more below.

## Use of Generative AI Tools

**No code in this project has been generated by or with the help of generative AI tools.**
However, generative AI tools were lightly utilized to speed up the gathering of information in cases where crawling through documentation manually way would have taken much longer.

## Project structure

The project is organised as a Bun-workspace monorepo with the following workspace members:

- Web (at `apps/web`): Bun, Vite, React, TailwindCSS, Tanstack Query, Tanstack Router, Base UI, Zod, Recharts, React Testing Library (and Caddy for prod docker image)
- Backend (at `apps/backend`): Bun, Hono, Drizzle, Zod, PGlite (ephemeral in-memory Postgres databsase for integration tests)
- E2E (at `e2e`): Bun, Playwright

Additionally, the project utilizes the following technologies and tooling:

- **Docker, Docker Compose and Docker Swarm** for containerization and container orchestration
- **Caddy and Traefik** (depending on the setup) for reverse proxying and load balancing
- **PostgreSQL** for data storage
- **GitHub Actions** for CI/CD
- **Oxlint, Oxfmt** for code correctness
- **Husky** for Git Hooks

A live deployment of the project is available publicly at https://dev-academy.myuwi.dev/.
The deployment is hosted via a Docker Swarm running on a Hetzner VPS which uses Traefik for reverse proxying and load balancing.
Updates to the deployment are managed automatically via the GitHub Actions CI/CD pipeline found in this repository.

## Features

Listed below are the features included in the application.

### Core features

- [x] Daily statistics list
  - [x] Total electricity production, consumption, average price, and longest consecutive time in hours, when electricity price has been negative, per day
  - [x] Pagination
  - [x] Ordering per column
  - [x] Searching by date
  - [x] Filtering by min and max values
- [x] Single day view
  - [x] Total electricity consumption per day
  - [x] Total electricity production per day
  - [x] Average electricity price per day
  - [x] Graph visualisations for Electricity production, consumption, and price throughout the day

### Surprise us with

- [x] (Mostly) Mobile Responsive
- [x] Create a database migration to tighten the database schema to ensure data correctness:
  - Make `id` an `IDENTITY` column with `GENERATED BY DEFAULT` for auto-incremented inserts
  - Make `date` and `starttime` `NOT NULL` to ensure the columns are not missing
  - Make `starttime` `UNIQUE` to prevent duplicate data from being inserted
- [x] Implement integration tests for API endpoints using Bun test runner and an ephemeral PGlite database
- [x] Implement (some) Component tests using React Testing Library
- [x] Implement E2E tests using Playwright
- [x] Add Pre-commit hooks for running linter and tests via Husky
- [x] Running backend in Docker (via Docker Compose or Docker Swarm)
- [x] Running backend in Cloud (via Docker Swarm and Traefik)
- [x] Implement a CI/CD pipeline that:
  - [x] Runs lints, unit tests, integration tests, and e2e tests
  - [x] Builds and publishes Docker images to GitHub Container Registry
  - [x] Deploys the project to a Cloud provider via Docker Stack Deploy over SSH
- [x] Implement Dark mode ðŸ˜Ž

### If I had more time

- [ ] Use correct time zone for aggregations (currently incorrectly assumes UTC)
- [ ] More tests

## Running the project

### Running locally for Development

#### Prerequisites

- Docker with Compose support
- [Bun](https://bun.com/) (v1.3.5+)

#### Steps

1. Start the database container using Docker Compose:

```sh
docker compose -f docker-compose.dev.yml up --build --renew-anon-volumes -d
```

2. Install project dependencies with Bun:

```sh
bun install
```

3. Start the web and backend development servers using Bun:

```sh
bun dev
```

4. Open the application at http://localhost:5173.

5. (Optional) You may then also run the test suites with the following commands:

```
# unit and integration tests
bun run test

# e2e tests
bunx playwright install --with-deps
bun run test:e2e
```

### Running locally via Docker Compose

#### Prerequisites

- Docker with Compose support

#### Steps

1. Start the application services using Docker Compose:

```sh
docker compose up --build --renew-anon-volumes -d
```

2. Open the application at http://localhost:8081.

### Publishing the images and deploying to the Cloud via Docker Stack Deploy and Traefik

The project includes a Docker Swarm stack file (`docker-stack.yml`), which is configured to work with [Traefik](https://doc.traefik.io/traefik/) as a reverse proxy and load balancer.

#### Prerequisites

- Docker with Compose and Swarm support
- Server with a domain, HTTP/HTTPS access, and Traefik with the `swarm` provider and TLS via Let's Encrypt configured

<details>
<summary>Minimal configuration for running Traefik using Docker Compose</summary>

```
.
â”œâ”€â”€ certs
â”‚Â Â  â””â”€â”€ acme.json # empty file
â””â”€â”€ docker-compose.yml
```

Create an overlay network:

```sh
docker network create --driver overlay --attachable proxy
```

Then in a `docker-compose.yml`:

```yml
services:
  traefik:
    image: traefik:v3.4
    container_name: traefik
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./certs:/etc/traefik/certs
    networks:
      - proxy
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
      - --entrypoints.web.http.redirections.entrypoint.permanent=true

      - --entrypoints.websecure.address=:443
      - --entrypoints.websecure.http.tls.certResolver=letsencrypt

      - --certificatesresolvers.letsencrypt.acme.email=email@example.com
      - --certificatesresolvers.letsencrypt.acme.storage=/etc/traefik/certs/acme.json
      - --certificatesresolvers.letsencrypt.acme.keyType=EC256
      - --certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web

      - --providers.swarm=true
      - --providers.swarm.endpoint=unix:///var/run/docker.sock
      - --providers.swarm.watch=true
      - --providers.swarm.exposedbydefault=false
      - --providers.swarm.network=proxy

networks:
  proxy:
    external: true
```

Then simply run Traefik with:

```sh
docker compose up -d
```

You should also set up logging etc. for your Traefik instance, but you should consult the [Traefik documentation](https://doc.traefik.io/traefik/setup/docker/) for more information about how to do this.

</details>

#### Steps

1. Prepare the `docker-compose.yml` and `docker-stack.yml` files by changing the image names and traefik host names to match your configuration.

2. Build the Docker images using Docker Compose:

```sh
docker compose build
```

3. Login to your container registry of choice:

```sh
docker login <...>
```

4. Push the images to the container registry:

```sh
docker push <CONTAINER_REGISTRY>/dev-academy-web:latest
docker push <CONTAINER_REGISTRY>/dev-academy-backend:latest
docker push <CONTAINER_REGISTRY>/dev-academy-db:latest
```

5. Connect to your remote server using a Docker context:

```sh
docker context create --docker host=ssh://<REMOTE_ADDRESS> <CONTEXT_NAME>
docker context use <CONTEXT_NAME>
```

Alternatively, you may also use `ssh` to connect to the remote server, but in that case you need to copy the needed `docker-stack.yml` file over.

6. Initialize the Docker Swarm:

```sh
docker swarm init
```

7. Deploy the stack to the Docker Swarm:

```sh
# If using only public images
docker stack deploy -c docker-stack.yml <STACK_NAME>
```

```sh
# If using any private images
docker login <...>
docker stack deploy --with-registry-auth -c docker-stack.yml <STACK_NAME>
```

8. After the deployment finishes, the application should become available under your configured domain.
